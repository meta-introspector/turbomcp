//! Tool macro implementation

use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{FnArg, ItemFn, Pat, PatType, Signature, Type, parse_macro_input};

/// Generate tool implementation with auto-discovery
pub fn generate_tool_impl(args: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as ItemFn);

    // Argument parsing - extract description
    let raw_args = args.to_string();
    let description = if raw_args.is_empty() {
        format!("Tool: {}", input.sig.ident)
    } else {
        // Extract description from various formats
        if let Some(desc_pos) = raw_args.find("description=") {
            let after_eq = &raw_args[desc_pos + 12..];
            if let Some(stripped) = after_eq.strip_prefix('"') {
                if let Some(end) = stripped.find('"') {
                    stripped[..end].to_string()
                } else {
                    raw_args.trim().trim_matches('"').to_string()
                }
            } else {
                raw_args.trim().trim_matches('"').to_string()
            }
        } else {
            // Assume the whole thing is a description
            raw_args.trim().trim_matches('"').to_string()
        }
    };

    let fn_name = &input.sig.ident;
    let fn_vis = &input.vis;
    let fn_block = &input.block;
    let fn_sig = &input.sig;
    let tool_name = fn_name.to_string();

    // Generate metadata function that can be tested
    let metadata_fn_name = syn::Ident::new(
        &format!("__turbomcp_tool_metadata_{fn_name}"),
        proc_macro2::Span::call_site(),
    );

    // Analyze function signature for schema generation
    let analysis = match analyze_function_signature(fn_sig) {
        Ok(analysis) => analysis,
        Err(err) => return err.to_compile_error().into(),
    };

    let schema_generation = generate_schema(&analysis);

    // Generate parameter extraction code
    let param_extraction = generate_parameter_extraction(&analysis);
    let call_args = &analysis.call_args;

    // Generate handler function name
    let handler_fn_name = syn::Ident::new(
        &format!("__turbomcp_tool_handler_{fn_name}"),
        proc_macro2::Span::call_site(),
    );

    // Generate public metadata function for testing
    let public_metadata_fn_name = syn::Ident::new(
        &format!("{}_metadata", fn_name),
        proc_macro2::Span::call_site(),
    );

    // Implementation that preserves function and enables auto-discovery
    let expanded = quote! {
        // Keep original function unchanged
        #fn_vis #fn_sig #fn_block

        // Generate metadata function as an associated function so server macro can call it
        #[doc(hidden)]
        #[allow(non_snake_case)]
        fn #metadata_fn_name() -> (&'static str, &'static str, serde_json::Value) {
            (#tool_name, #description, #schema_generation)
        }

        // Generate public metadata function for testing capability
        /// Get metadata for this tool (name, description, JSON schema)
        ///
        /// This function is generated by the #[tool] macro and provides direct access
        /// to the tool's metadata for integration testing and validation.
        pub fn #public_metadata_fn_name() -> (&'static str, &'static str, serde_json::Value) {
            Self::#metadata_fn_name()
        }

        // Generate handler function that bridges CallToolRequest to the actual method
        #[doc(hidden)]
        #[allow(non_snake_case)]
        fn #handler_fn_name(&self, request: turbomcp::CallToolRequest, context: turbomcp::RequestContext) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<turbomcp::CallToolResult, turbomcp::ServerError>> + Send + '_>> {
            Box::pin(async move {
                // Context injection using ContextFactory pattern
                let turbomcp_ctx = {
                    // Create a context factory with optimized configuration
                    use turbomcp::{ContextFactory, ContextFactoryConfig, Container};

                    // Use a static context factory for maximum performance (in practice, this would be a server instance field)
                    // TODO: In the future, we'll integrate this with server-level ContextFactory instance
                    let config = ContextFactoryConfig {
                        enable_tracing: true,
                        enable_metrics: true,
                        max_pool_size: 50,
                        default_strategy: turbomcp::ContextCreationStrategy::Inherit,
                        ..Default::default()
                    };
                    let container = Container::new();
                    let factory = ContextFactory::new(config, container);

                    // Use the factory to create context with proper error handling
                    factory.create_for_tool(context.clone(), #tool_name, Some(#description))
                        .await
                        .unwrap_or_else(|_| {
                            // Fallback to basic context if factory fails
                            let handler_metadata = turbomcp::HandlerMetadata {
                                name: #tool_name.to_string(),
                                handler_type: "tool".to_string(),
                                description: Some(#description.to_string()),
                            };
                            turbomcp::Context::new(context, handler_metadata)
                        })
                };

                #param_extraction

                // Call the actual method with extracted parameters (self is already available)
                let result = self.#fn_name(#call_args).await
                    .map_err(|e| match e {
                        turbomcp::McpError::Server(server_err) => server_err,
                        turbomcp::McpError::Tool(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::Resource(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::Prompt(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::Protocol(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::Context(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::Unauthorized(msg) => turbomcp::ServerError::authorization(msg),
                        turbomcp::McpError::Network(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::InvalidInput(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::Schema(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::Transport(msg) => turbomcp::ServerError::handler(msg),
                        turbomcp::McpError::Serialization(e) => turbomcp::ServerError::from(e),
                        turbomcp::McpError::Internal(msg) => turbomcp::ServerError::Internal(msg),
                        turbomcp::McpError::InvalidRequest(msg) => turbomcp::ServerError::handler(msg),
                    })?;

                // Convert result to CallToolResult - properly serialize the result
                let text = match ::serde_json::to_value(&result) {
                    Ok(val) if val.is_string() => {
                        // If result is already a string, use it directly
                        val.as_str().unwrap_or("").to_string()
                    }
                    Ok(val) => {
                        // For other types, use JSON representation
                        ::serde_json::to_string(&val).unwrap_or_else(|_| format!("{:?}", result))
                    }
                    Err(_) => {
                        // Fallback to Debug (Display not guaranteed for all types)
                        format!("{:?}", result)
                    }
                };

                Ok(turbomcp::CallToolResult {
                    content: vec![turbomcp::Content::Text(turbomcp::TextContent {
                        text,
                        annotations: None,
                        meta: None,
                    })],
                    is_error: Some(false),  // Explicitly mark as success
                })
            })
        }
    };

    TokenStream::from(expanded)
}

/// Analysis of function signature
struct FunctionAnalysis {
    parameters: Vec<ParameterInfo>,
    #[allow(dead_code)]
    call_args: TokenStream2,
    #[allow(dead_code)]
    _has_context: bool,
    #[allow(dead_code)]
    has_self: bool,
}

/// Information about a parameter
struct ParameterInfo {
    name: String,
    ty: Type,
    _is_context: bool,
}

/// Analyze function signature to extract parameters and generate appropriate code
fn analyze_function_signature(sig: &Signature) -> Result<FunctionAnalysis, syn::Error> {
    let mut parameters = Vec::new();
    let mut call_args = TokenStream2::new();
    let mut has_context = false;
    let mut has_self = false;
    let mut first_param = true;

    for input in &sig.inputs {
        match input {
            FnArg::Receiver(_) => {
                // &self parameter - mark as method but don't include in call args
                // since self is already available in method context
                has_self = true;
                continue;
            }
            FnArg::Typed(PatType { pat, ty, .. }) => {
                if let Pat::Ident(pat_ident) = pat.as_ref() {
                    let param_name = &pat_ident.ident;

                    // Check if this is a Context parameter
                    let is_context = if let Type::Path(type_path) = ty.as_ref() {
                        type_path
                            .path
                            .segments
                            .last()
                            .is_some_and(|seg| seg.ident == "Context")
                    } else {
                        false
                    };

                    if is_context {
                        has_context = true;
                        if !first_param {
                            call_args.extend(quote! { , });
                        }
                        call_args.extend(quote! { turbomcp_ctx });
                    } else {
                        parameters.push(ParameterInfo {
                            name: param_name.to_string(),
                            ty: (**ty).clone(),
                            _is_context: false,
                        });

                        if !first_param {
                            call_args.extend(quote! { , });
                        }
                        call_args.extend(quote! { #param_name });
                    }

                    first_param = false;
                }
            }
        }
    }

    Ok(FunctionAnalysis {
        parameters,
        call_args,
        _has_context: has_context,
        has_self,
    })
}

/// Generate parameter extraction code
#[allow(dead_code)]
fn generate_parameter_extraction(analysis: &FunctionAnalysis) -> TokenStream2 {
    if analysis.parameters.is_empty() {
        return quote! {};
    }

    let mut extraction_code = quote! {};

    // Check if we have any parameters to extract
    let has_params = !analysis.parameters.is_empty();
    if has_params {
        extraction_code.extend(quote! {
            let arguments = request.arguments.as_ref();
        });
    }

    for param in &analysis.parameters {
        let param_name_str = &param.name;
        let param_name_ident = syn::Ident::new(&param.name, proc_macro2::Span::call_site());
        let param_ty = &param.ty;

        // Check if this is an optional parameter
        let is_optional = is_option_type(&param.ty);

        if is_optional {
            // For optional parameters, use None if not present
            extraction_code.extend(quote! {
                let #param_name_ident: #param_ty = if let Some(args) = arguments {
                    args.get(#param_name_str)
                        .map(|v| ::serde_json::from_value(v.clone())
                            .map_err(|e| turbomcp::ServerError::handler(
                                format!("Invalid parameter {}: {}", #param_name_str, e)
                            )))
                        .transpose()?
                        .flatten()
                } else {
                    None
                };
            });
        } else {
            // For required parameters, fail if not present
            extraction_code.extend(quote! {
                let #param_name_ident = arguments
                    .as_ref()
                    .ok_or_else(|| turbomcp::ServerError::handler("Missing arguments"))?
                    .get(#param_name_str)
                    .ok_or_else(|| turbomcp::ServerError::handler(
                        format!("Missing required parameter: {}", #param_name_str)
                    ))?;
                let #param_name_ident: #param_ty = ::serde_json::from_value(#param_name_ident.clone())
                    .map_err(|e| turbomcp::ServerError::handler(
                        format!("Invalid parameter {}: {}", #param_name_str, e)
                    ))?;
            });
        }
    }

    extraction_code
}

/// Check if a type is Option<T>
fn is_option_type(ty: &Type) -> bool {
    match ty {
        Type::Path(type_path) => {
            if let Some(segment) = type_path.path.segments.last() {
                segment.ident == "Option"
            } else {
                false
            }
        }
        _ => false,
    }
}

/// Generate JSON schema for the tool
fn generate_schema(analysis: &FunctionAnalysis) -> TokenStream2 {
    if analysis.parameters.is_empty() {
        return quote! {
            {
                let mut schema_map = ::serde_json::Map::new();
                schema_map.insert("type".to_string(), ::serde_json::Value::String("object".to_string()));
                schema_map.insert("properties".to_string(), ::serde_json::Value::Object(::serde_json::Map::new()));
                schema_map.insert("required".to_string(), ::serde_json::Value::Array(Vec::new()));
                schema_map.insert("additionalProperties".to_string(), ::serde_json::Value::Bool(false));
                ::serde_json::Value::Object(schema_map)
            }
        };
    }

    // Build properties map using per-parameter type mapping (fallback)
    let mut prop_entries: Vec<(syn::LitStr, TokenStream2)> = Vec::new();
    let mut required_entries: Vec<syn::LitStr> = Vec::new();

    for p in &analysis.parameters {
        let key = syn::LitStr::new(&p.name, proc_macro2::Span::call_site());
        let schema_ts = crate::schema::generate_json_schema(&p.ty);
        prop_entries.push((key.clone(), schema_ts));

        // Check if this parameter is required (non-Option type)
        let is_optional = is_option_type(&p.ty);
        if !is_optional {
            required_entries.push(key);
        }
    }

    let keys: Vec<syn::LitStr> = prop_entries.iter().map(|(k, _)| k.clone()).collect();
    let values: Vec<TokenStream2> = prop_entries.iter().map(|(_, v)| v.clone()).collect();

    quote! {
        {
            let mut schema_map = ::serde_json::Map::new();
            schema_map.insert("type".to_string(), ::serde_json::Value::String("object".to_string()));

            let mut properties_map = ::serde_json::Map::new();
            #(
                properties_map.insert(#keys.to_string(), #values);
            )*
            schema_map.insert("properties".to_string(), ::serde_json::Value::Object(properties_map));

            let required_array = vec![#(::serde_json::Value::String(#required_entries.to_string())),*];
            schema_map.insert("required".to_string(), ::serde_json::Value::Array(required_array));
            schema_map.insert("additionalProperties".to_string(), ::serde_json::Value::Bool(false));

            ::serde_json::Value::Object(schema_map)
        }
    }
}
