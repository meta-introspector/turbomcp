#![allow(dead_code)]
//! # 05: Advanced Patterns - Production-Ready Error Handling & Async Patterns
//!
//! **Learning Goals (25 minutes):**
//! - Master robust error handling strategies
//! - Learn advanced async patterns and concurrency
//! - Understand input validation and sanitization
//! - See retry logic and circuit breaker patterns
//! - Implement proper resource cleanup and cancellation
//!
//! **What this example demonstrates:**
//! - Comprehensive error handling with context
//! - Advanced async patterns (timeouts, cancellation, parallelization)
//! - Input validation with custom validators
//! - Retry logic with exponential backoff
//! - Circuit breaker pattern for external services
//! - Resource management and cleanup
//! - Performance monitoring and metrics
//!
//! **Run with:** `cargo run --example 05_advanced_patterns`

use serde::{Deserialize, Serialize};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::time::{sleep, timeout};
use turbomcp::prelude::*;

/// Advanced server demonstrating production-ready patterns
#[derive(Debug, Clone)]
struct AdvancedPatternsServer {
    /// Circuit breaker for external API calls
    circuit_breaker: Arc<tokio::sync::Mutex<CircuitBreakerState>>,
    /// Metrics collection
    metrics: Arc<tokio::sync::RwLock<ServerMetrics>>,
    /// Active operations for cancellation
    active_operations: Arc<
        tokio::sync::RwLock<std::collections::HashMap<String, tokio::sync::oneshot::Sender<()>>>,
    >,
}

#[derive(Debug)]
struct CircuitBreakerState {
    failures: u32,
    last_failure: Option<Instant>,
    state: CircuitState,
}

#[derive(Debug, Clone, Copy)]
enum CircuitState {
    Closed,   // Normal operation
    Open,     // Failing, reject requests
    HalfOpen, // Testing if service recovered
}

#[derive(Debug, Default)]
struct ServerMetrics {
    requests_total: u64,
    requests_successful: u64,
    requests_failed: u64,
    average_duration: Duration,
}

#[derive(Debug, Deserialize, Serialize)]
struct ApiRequest {
    url: String,
    method: Option<String>, // GET, POST, PUT, DELETE
    headers: Option<std::collections::HashMap<String, String>>,
    body: Option<String>,
    timeout_seconds: Option<u64>,
    retry_attempts: Option<u32>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ValidationRules {
    min_length: Option<usize>,
    max_length: Option<usize>,
    pattern: Option<String>, // regex pattern
    required: Option<bool>,
    allowed_values: Option<Vec<String>>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ProcessingTask {
    task_type: String, // "cpu_intensive", "io_bound", "network"
    data: serde_json::Value,
    timeout_seconds: Option<u64>,
    parallel: Option<bool>,
    chunks: Option<usize>,
}

#[turbomcp::server(name = "AdvancedPatternsServer", version = "1.0.0")]
impl AdvancedPatternsServer {
    fn new() -> Self {
        Self {
            circuit_breaker: Arc::new(tokio::sync::Mutex::new(CircuitBreakerState {
                failures: 0,
                last_failure: None,
                state: CircuitState::Closed,
            })),
            metrics: Arc::new(tokio::sync::RwLock::new(ServerMetrics::default())),
            active_operations: Arc::new(tokio::sync::RwLock::new(std::collections::HashMap::new())),
        }
    }

    /// Update circuit breaker state based on operation result
    async fn update_circuit_breaker(&self, success: bool) {
        let mut breaker = self.circuit_breaker.lock();

        match success {
            true => {
                breaker.failures = 0;
                breaker.state = CircuitState::Closed;
            }
            false => {
                breaker.failures += 1;
                breaker.last_failure = Some(Instant::now());

                if breaker.failures >= 5 {
                    breaker.state = CircuitState::Open;
                }
            }
        }
    }

    /// Check if circuit breaker allows operation
    async fn circuit_breaker_allows(&self) -> bool {
        let mut breaker = self.circuit_breaker.lock();

        match breaker.state {
            CircuitState::Closed => true,
            CircuitState::Open => {
                // Check if we should try half-open
                if let Some(last_failure) = breaker.last_failure {
                    if last_failure.elapsed() > Duration::from_secs(30) {
                        breaker.state = CircuitState::HalfOpen;
                        true
                    } else {
                        false
                    }
                } else {
                    false
                }
            }
            CircuitState::HalfOpen => true,
        }
    }

    /// Record metrics for an operation
    async fn record_metrics(&self, duration: Duration, success: bool) {
        let mut metrics = self.metrics.write();
        metrics.requests_total += 1;

        if success {
            metrics.requests_successful += 1;
        } else {
            metrics.requests_failed += 1;
        }

        // Simple moving average (in production, use proper metrics collection)
        let total_duration = metrics.average_duration.as_millis()
            * (metrics.requests_total - 1) as u128
            + duration.as_millis();
        metrics.average_duration =
            Duration::from_millis((total_duration / metrics.requests_total as u128) as u64);
    }

    /// Validate input against rules
    fn validate_input(&self, value: &str, rules: &ValidationRules) -> McpResult<()> {
        // Required validation
        if rules.required.unwrap_or(false) && value.is_empty() {
            return Err(McpError::invalid_request("Value is required but empty"));
        }

        // Length validation
        if let Some(min_len) = rules.min_length {
            if value.len() < min_len {
                return Err(McpError::invalid_request(format!(
                    "Value too short (min: {} chars, got: {})",
                    min_len,
                    value.len()
                )));
            }
        }

        if let Some(max_len) = rules.max_length {
            if value.len() > max_len {
                return Err(McpError::invalid_request(format!(
                    "Value too long (max: {} chars, got: {})",
                    max_len,
                    value.len()
                )));
            }
        }

        // Pattern validation (simplified - in production use proper regex crate)
        if let Some(pattern) = &rules.pattern {
            if pattern == "email" && !value.contains('@') {
                return Err(McpError::invalid_request("Invalid email format"));
            }
            if pattern == "url" && !value.starts_with("http") {
                return Err(McpError::invalid_request("Invalid URL format"));
            }
        }

        // Allowed values validation
        if let Some(allowed) = &rules.allowed_values {
            if !allowed.contains(&value.to_string()) {
                return Err(McpError::invalid_request(format!(
                    "Value not allowed. Allowed values: {allowed:?}"
                )));
            }
        }

        Ok(())
    }
}

impl AdvancedPatternsServer {
    /// Advanced HTTP request with circuit breaker and retry logic
    #[tool("Make HTTP request with advanced error handling and retry logic")]
    async fn advanced_http_request(&self, params: ApiRequest) -> McpResult<String> {
        let start_time = Instant::now();
        let operation_id = uuid::Uuid::new_v4().to_string();

        let _ = ctx
            .info(&format!(
                "Starting HTTP request to: {} (ID: {})",
                params.url, operation_id
            ))
            .await;

        // Validate URL format
        self.validate_input(
            &params.url,
            &ValidationRules {
                min_length: Some(10),
                max_length: Some(2048),
                pattern: Some("url".to_string()),
                required: Some(true),
                allowed_values: None,
            },
        )?;

        // Check circuit breaker
        if !self.circuit_breaker_allows().await {
            let _ = ctx
                .warn("Circuit breaker is OPEN - rejecting request")
                .await;
            return Err(McpError::internal(
                "External service is currently unavailable (circuit breaker open)",
            ));
        }

        let retry_attempts = params.retry_attempts.unwrap_or(3);
        let url = params.url.clone();
        let method = params.method.clone().unwrap_or_else(|| "GET".to_string());

        // Simplified retry logic without complex closures
        let mut attempts = 0;
        let mut delay = Duration::from_millis(100);
        let mut last_error = None;

        while attempts < retry_attempts {
            attempts += 1;
            let _ = ctx
                .info(&format!(
                    "Attempt {attempts}/{retry_attempts} for HTTP request"
                ))
                .await;

            // Simulate HTTP request (in real implementation, use reqwest or similar)
            tracing::info!(&format!("Making {method} request to {url}"));

            // Simulate network delay and potential failure
            sleep(Duration::from_millis(200 + (rand::random::<u64>() % 800)));

            // Simulate occasional failures for demonstration
            if rand::random::<u32>() % 5 == 0 {
                // Simulate 20% failure rate
                let error = McpError::internal("Simulated network error");
                last_error = Some(error.clone());

                if attempts >= retry_attempts {
                    let _ = ctx
                        .error(&format!(
                            "HTTP request failed after {attempts} attempts: {error}"
                        ))
                        .await;
                    let duration = start_time.elapsed();
                    self.update_circuit_breaker(false);
                    self.record_metrics(duration, false);
                    return Err(error);
                }

                let _ = ctx
                    .warn(&format!(
                        "Attempt {attempts} failed: {error}, retrying in {delay:?}"
                    ))
                    .await;
                sleep(delay);

                // Exponential backoff with jitter
                delay = Duration::from_millis((delay.as_millis() * 2).min(5000) as u64);
                delay += Duration::from_millis(50 + (rand::random::<u64>() % 100));
                continue;
            }

            // Success case
            let response = serde_json::json!({
                "status": 200,
                "method": method,
                "url": url,
                "timestamp": chrono::Utc::now().to_rfc3339(),
                "headers": {
                    "content-type": "application/json",
                    "server": "TurboMCP-Simulator"
                },
                "body": "Simulated successful response"
            });

            let duration = start_time.elapsed();
            self.update_circuit_breaker(true);
            self.record_metrics(duration, true);

            if attempts > 1 {
                let _ = ctx
                    .info(&format!("HTTP request succeeded after {attempts} attempts"))
                    .await;
            }
            let _ = ctx
                .info(&format!(
                    "HTTP request completed successfully in {duration:?}"
                ))
                .await;
            return Ok(response.to_string());
        }

        // This should never be reached, but just in case
        Err(last_error.unwrap_or_else(|| McpError::internal("Unknown error")))
    }

    /// Validate input with comprehensive rules
    #[tool("Validate input against comprehensive validation rules")]
    async fn validate_with_rules(
        &self,
        value: String,
        rules: ValidationRules,
    ) -> McpResult<String> {
        let _ = ctx
            .info(&format!("Validating value with {} rules", {
                let mut count = 0;
                if rules.min_length.is_some() {
                    count += 1;
                }
                if rules.max_length.is_some() {
                    count += 1;
                }
                if rules.pattern.is_some() {
                    count += 1;
                }
                if rules.required.is_some() {
                    count += 1;
                }
                if rules.allowed_values.is_some() {
                    count += 1;
                }
                count
            }))
            .await;

        // Perform validation
        self.validate_input(&value, &rules)?;

        tracing::info!("Input validation passed successfully");

        Ok(format!("âœ… Input '{value}' passed all validation rules"))
    }

    /// Process data with advanced async patterns
    #[tool("Process data with advanced async patterns (parallelization, timeouts, cancellation)")]
    async fn advanced_processing(&self, task: ProcessingTask) -> McpResult<String> {
        let start_time = Instant::now();
        let operation_id = uuid::Uuid::new_v4().to_string();

        let _ = ctx
            .info(&format!(
                "Starting {} processing (ID: {})",
                task.task_type, operation_id
            ))
            .await;

        let timeout_duration = Duration::from_secs(task.timeout_seconds.unwrap_or(60));

        let result = timeout(timeout_duration, async {
            match task.task_type.as_str() {
                "cpu_intensive" => {
                    tracing::info!("Performing CPU-intensive computation");

                    if task.parallel.unwrap_or(false) {
                        // Parallel processing simulation
                        let chunks = task.chunks.unwrap_or(4);
                        let mut tasks = Vec::new();

                        for i in 0..chunks {
                            // Note: Context is not Clone, so we can't pass it to spawned tasks
                            tasks.push(tokio::spawn(async move {
                                tracing::info!("Processing chunk {}", i);
                                sleep(Duration::from_millis(100 + (rand::random::<u64>() % 200)))
                                    .await;
                                format!("chunk_{i}_result")
                            }));
                        }

                        let results: Vec<String> =
                            futures::future::try_join_all(tasks).await.map_err(|e| {
                                McpError::internal(format!("Parallel processing failed: {e}"))
                            })?;

                        Ok(format!("Parallel processing completed: {results:?}"))
                    } else {
                        // Sequential processing
                        sleep(Duration::from_millis(500));
                        Ok("CPU-intensive task completed sequentially".to_string())
                    }
                }
                "io_bound" => {
                    tracing::info!("Performing I/O-bound operations");

                    // Simulate multiple I/O operations
                    let mut results = Vec::new();
                    for i in 1..=3 {
                        tracing::info!(&format!("I/O operation {i}/3"));
                        sleep(Duration::from_millis(150));
                        results.push(format!("io_result_{i}"));
                    }

                    Ok(format!("I/O operations completed: {results:?}"))
                }
                "network" => {
                    let _ = ctx
                        .info("Performing network operations with error handling")
                        .await;

                    // Use circuit breaker for network operations
                    if !self.circuit_breaker_allows().await {
                        return Err(McpError::internal("Network services unavailable"));
                    }

                    // Simulate network operation with potential failure
                    sleep(Duration::from_millis(300));

                    if rand::random::<u32>() % 7 == 0 {
                        // Simulate 15% failure rate
                        self.update_circuit_breaker(false);
                        return Err(McpError::internal("Network operation failed"));
                    }

                    self.update_circuit_breaker(true);
                    Ok("Network operations completed successfully".to_string())
                }
                _ => Err(McpError::invalid_request(
                    "Unknown task type. Supported: cpu_intensive, io_bound, network",
                )),
            }
        })
        .await;

        let duration = start_time.elapsed();

        match result {
            Ok(inner_result) => match inner_result {
                Ok(message) => {
                    let _ = ctx
                        .info(&format!(
                            "Processing completed successfully in {duration:?}"
                        ))
                        .await;
                    self.record_metrics(duration, true);
                    Ok(message)
                }
                Err(e) => {
                    let _ = ctx
                        .error(&format!("Processing failed in {duration:?}: {e}"))
                        .await;
                    self.record_metrics(duration, false);
                    Err(e)
                }
            },
            Err(_) => {
                let _ = ctx
                    .error(&format!("Processing timed out after {duration:?}"))
                    .await;
                self.record_metrics(duration, false);
                Err(McpError::internal("Processing operation timed out"))
            }
        }
    }

    /// Get detailed server metrics and health status
    #[tool("Get comprehensive server metrics, circuit breaker status, and health information")]
    async fn get_advanced_metrics(&self) -> McpResult<String> {
        tracing::info!("Gathering comprehensive server metrics");

        let metrics = self.metrics.read();
        let circuit_breaker = self.circuit_breaker.lock();
        let active_ops = self.active_operations.read();

        let health_status = match circuit_breaker.state {
            CircuitState::Closed => "healthy",
            CircuitState::HalfOpen => "degraded",
            CircuitState::Open => "unhealthy",
        };

        let success_rate = if metrics.requests_total > 0 {
            (metrics.requests_successful as f64 / metrics.requests_total as f64) * 100.0
        } else {
            0.0
        };

        let detailed_metrics = serde_json::json!({
            "server_health": {
                "status": health_status,
                "uptime": "N/A", // Would track actual uptime in production
                "version": "1.0.0"
            },
            "request_metrics": {
                "total_requests": metrics.requests_total,
                "successful_requests": metrics.requests_successful,
                "failed_requests": metrics.requests_failed,
                "success_rate_percent": format!("{:.2}%", success_rate),
                "average_response_time": format!("{:?}", metrics.average_duration)
            },
            "circuit_breaker": {
                "state": format!("{:?}", circuit_breaker.state),
                "failure_count": circuit_breaker.failures,
                "last_failure": circuit_breaker.last_failure.map(|t| {
                    format!("{:?} ago", t.elapsed())
                })
            },
            "active_operations": {
                "count": active_ops.len(),
                "operation_ids": active_ops.keys().collect::<Vec<_>>()
            },
            "patterns_demonstrated": [
                "Circuit breaker pattern",
                "Retry with exponential backoff",
                "Input validation with custom rules",
                "Timeout handling",
                "Parallel processing",
                "Metrics collection",
                "Operation cancellation",
                "Comprehensive error handling"
            ]
        });

        Ok(detailed_metrics.to_string())
    }

    /// Cancel an active operation
    #[tool("Cancel an active operation by its ID")]
    async fn cancel_operation(&self, operation_id: String) -> McpResult<String> {
        let _ = ctx
            .info(&format!("Attempting to cancel operation: {operation_id}"))
            .await;

        let mut active_ops = self.active_operations.write();

        if let Some(cancel_tx) = active_ops.remove(&operation_id) {
            if cancel_tx.send(()).is_ok() {
                let _ = ctx
                    .info(&format!("Successfully cancelled operation: {operation_id}"))
                    .await;
                Ok(format!("Operation {operation_id} cancelled successfully"))
            } else {
                let _ = ctx
                    .warn(&format!("Operation {operation_id} was already completing"))
                    .await;
                Ok(format!("Operation {operation_id} was already completing"))
            }
        } else {
            Err(McpError::resource(
                "Operation not found or already completed",
            ))
        }
    }

    /// Simulate a controlled failure for testing error handling
    #[tool("Simulate various types of failures for testing error handling")]
    async fn simulate_failure(&self, failure_type: String) -> McpResult<String> {
        let _ = ctx
            .info(&format!("Simulating {failure_type} failure"))
            .await;

        match failure_type.as_str() {
            "timeout" => {
                sleep(Duration::from_secs(10)); // Will timeout if client timeout < 10s
                Ok("This should not be reached".to_string())
            }
            "invalid_request" => {
                Err(McpError::invalid_request("Simulated invalid request error"))
            }
            "internal_error" => {
                Err(McpError::internal("Simulated internal server error"))
            }
            "service_unavailable" => {
                Err(McpError::internal("Simulated service unavailable"))
            }
            "not_found" => {
                Err(McpError::resource("Simulated resource not found"))
            }
            "cancelled" => {
                Err(McpError::internal("Simulated operation cancelled"))
            }
            _ => {
                Err(McpError::invalid_request(
                    "Unknown failure type. Supported: timeout, invalid_request, internal_error, service_unavailable, not_found, cancelled"
                ))
            }
        }
    }
}

#[tokio::main]
async fn main() -> McpResult<()> {
    tracing_subscriber::fmt()
        .with_env_filter("info")
        .with_target(false)
        .with_thread_ids(true)
        .init();

    tracing::info!("ðŸ”¥ Starting Advanced Patterns MCP Server");
    tracing::info!("========================================");
    tracing::info!("Patterns: Error handling, Circuit breakers, Retries, Validation");
    tracing::info!("Features: Timeouts, Cancellation, Metrics, Async patterns");

    let server = AdvancedPatternsServer::new();

    tracing::info!("Server ready! Try the advanced tools to see production patterns in action.");

    server
        .run_stdio()
        .await
        .map_err(|e| McpError::internal(format!("Server error: {e}")))
}

/* ðŸŽ¯ **Try these advanced pattern examples:**

**HTTP with retry and circuit breaker:**
- advanced_http_request({"url": "https://httpbin.org/delay/1", "retry_attempts": 3, "timeout_seconds": 5})
- Try multiple failed requests to trigger circuit breaker

**Input validation:**
- validate_with_rules("test@example.com", {"pattern": "email", "min_length": 5, "required": true})
- validate_with_rules("short", {"min_length": 10}) // Should fail

**Advanced async processing:**
- advanced_processing({"task_type": "cpu_intensive", "parallel": true, "chunks": 8})
- advanced_processing({"task_type": "network", "timeout_seconds": 10})

**Metrics and monitoring:**
- get_advanced_metrics() // See server health and circuit breaker state

**Error handling examples:**
- simulate_failure("timeout") // Test timeout handling
- simulate_failure("invalid_request") // Test validation errors

**Key Production Patterns Demonstrated:**
âœ… Circuit breaker pattern with automatic recovery
âœ… Retry with exponential backoff and jitter
âœ… Comprehensive input validation with custom rules
âœ… Timeout handling with graceful degradation
âœ… Operation cancellation and cleanup
âœ… Parallel processing with error aggregation
âœ… Metrics collection and health monitoring
âœ… Structured error handling with context
âœ… Resource management and leak prevention

**Next:** `06_authentication_security.rs` - Security, auth, and session management
*/
